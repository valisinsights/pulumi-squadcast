// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface DeduplicationRulesRule {
    /**
     * The basic expression which needs to be evaluated to be true for this rule to apply.
     */
    basicExpressions?: pulumi.Input<pulumi.Input<inputs.DeduplicationRulesRuleBasicExpression>[]>;
    /**
     * Denotes if dependent services should also be deduplicated
     */
    dependencyDeduplication?: pulumi.Input<boolean>;
    /**
     * description.
     */
    description?: pulumi.Input<string>;
    /**
     * The expression which needs to be evaluated to be true for this rule to apply.
     */
    expression?: pulumi.Input<string>;
    /**
     * is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
     */
    isBasic: pulumi.Input<boolean>;
    /**
     * time unit (mins or hours)
     */
    timeUnit?: pulumi.Input<string>;
    /**
     * integer for time_unit
     */
    timeWindow?: pulumi.Input<number>;
}

export interface DeduplicationRulesRuleBasicExpression {
    lhs: pulumi.Input<string>;
    op: pulumi.Input<string>;
    rhs: pulumi.Input<string>;
}

export interface EscalationPolicyEntityOwner {
    /**
     * Escalation policy owner id.
     */
    id: pulumi.Input<string>;
    /**
     * Escalation policy owner type. (user or squad or team)
     */
    type: pulumi.Input<string>;
}

export interface EscalationPolicyRepeat {
    /**
     * The number of minutes to wait before repeating the escalation policy
     */
    delayMinutes: pulumi.Input<number>;
    /**
     * The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
     */
    times: pulumi.Input<number>;
}

export interface EscalationPolicyRule {
    delayMinutes: pulumi.Input<number>;
    notificationChannels?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * repeat this rule
     */
    repeat?: pulumi.Input<inputs.EscalationPolicyRuleRepeat>;
    roundRobin?: pulumi.Input<inputs.EscalationPolicyRuleRoundRobin>;
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPolicyRuleTarget>[]>;
}

export interface EscalationPolicyRuleRepeat {
    /**
     * The number of minutes to wait before repeating the escalation policy
     */
    delayMinutes: pulumi.Input<number>;
    /**
     * The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
     */
    times: pulumi.Input<number>;
}

export interface EscalationPolicyRuleRoundRobin {
    enabled: pulumi.Input<boolean>;
    rotation?: pulumi.Input<inputs.EscalationPolicyRuleRoundRobinRotation>;
}

export interface EscalationPolicyRuleRoundRobinRotation {
    delayMinutes?: pulumi.Input<number>;
    enabled?: pulumi.Input<boolean>;
}

export interface EscalationPolicyRuleTarget {
    /**
     * EscalationPolicy id.
     */
    id: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface RoutingRulesRule {
    /**
     * The basic expression which needs to be evaluated to be true for this rule to apply.
     */
    basicExpressions?: pulumi.Input<pulumi.Input<inputs.RoutingRulesRuleBasicExpression>[]>;
    /**
     * The expression which needs to be evaluated to be true for this rule to apply.
     */
    expression?: pulumi.Input<string>;
    /**
     * is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
     */
    isBasic: pulumi.Input<boolean>;
    /**
     * The id of the entity (user, escalation policy, squad) for which we are routing this incident.
     */
    routeToId: pulumi.Input<string>;
    /**
     * Type of the entity for which we are routing this incident - User, Escalation Policy or Squad
     */
    routeToType: pulumi.Input<string>;
}

export interface RoutingRulesRuleBasicExpression {
    lhs: pulumi.Input<string>;
    rhs: pulumi.Input<string>;
}

export interface RunbookEntityOwner {
    /**
     * Runbook owner id.
     */
    id: pulumi.Input<string>;
    /**
     * Runbook owner type. (user or squad or team)
     */
    type: pulumi.Input<string>;
}

export interface RunbookStep {
    content: pulumi.Input<string>;
}

export interface SLOEntityOwner {
    /**
     * SLO owner id.
     */
    id: pulumi.Input<string>;
    /**
     * SLO owner type (user, team, squad).
     */
    type: pulumi.Input<string>;
}

export interface SLONotify {
    /**
     * The ID of the notification rule
     */
    id?: pulumi.Input<number>;
    /**
     * The ID of the service in which the user want to create an incident
     */
    serviceId?: pulumi.Input<string>;
    /**
     * The ID of the SLO.
     */
    sloId?: pulumi.Input<number>;
    /**
     * List of Squad ID's who should be alerted via email.
     */
    squadIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of user ID's who should be alerted via email.
     */
    userIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SLORule {
    /**
     * The ID of the monitoring rule
     */
    id?: pulumi.Input<number>;
    /**
     * Is checked?
     */
    isChecked?: pulumi.Input<boolean>;
    /**
     * The name of monitoring check."Supported values are "breached*error*budget", "unhealthy*slo","increased*false*positives", "remaining*error_budget"
     */
    name: pulumi.Input<string>;
    /**
     * The ID of the SLO
     */
    sloId?: pulumi.Input<number>;
    /**
     * Threshold for the monitoring checkOnly supported for rules name "increased*false*positives" and "remaining*error*budget"
     */
    threshold?: pulumi.Input<number>;
}

export interface ScheduleRotationV2ParticipantGroup {
    /**
     * Group participants.
     */
    participants?: pulumi.Input<pulumi.Input<inputs.ScheduleRotationV2ParticipantGroupParticipant>[]>;
}

export interface ScheduleRotationV2ParticipantGroupParticipant {
    /**
     * Rotation id.
     */
    id: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface ScheduleRotationV2ShiftTimeslot {
    /**
     * Defines the day of the week for the shift. If not specified, the timeslot is active on all days of the week.
     */
    dayOfWeek?: pulumi.Input<string>;
    /**
     * Defines the duration of each shift. (in minutes)
     */
    duration: pulumi.Input<number>;
    /**
     * Defines the start hour of the each shift in the schedule timezone.
     */
    startHour: pulumi.Input<number>;
    /**
     * Defines the start minute of the each shift in the schedule timezone.
     */
    startMinute: pulumi.Input<number>;
}

export interface ScheduleV2EntityOwner {
    /**
     * Schedule owner id.
     */
    id: pulumi.Input<string>;
    /**
     * Schedule owner type (user, team, squad).
     */
    type: pulumi.Input<string>;
}

export interface ScheduleV2Tag {
    /**
     * Schedule tag color.
     */
    color?: pulumi.Input<string>;
    /**
     * Schedule tag key.
     */
    key: pulumi.Input<string>;
    /**
     * Schedule tag value.
     */
    value: pulumi.Input<string>;
}

export interface SebformInputField {
    /**
     * Input field Label.
     */
    label?: pulumi.Input<string>;
    /**
     * Input field options.
     */
    options?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SebformOwner {
    /**
     * Form owner id.
     */
    id: pulumi.Input<string>;
    /**
     * Form owner name.
     */
    name?: pulumi.Input<string>;
    /**
     * Form owner type (user, team, squad).
     */
    type: pulumi.Input<string>;
}

export interface SebformService {
    /**
     * Service alias.
     */
    alias?: pulumi.Input<string>;
    /**
     * Service name.
     */
    name?: pulumi.Input<string>;
    /**
     * Service ID.
     */
    serviceId: pulumi.Input<string>;
}

export interface SebformSeverity {
    /**
     * Severity description.
     */
    description?: pulumi.Input<string>;
    /**
     * Severity type.
     */
    type: pulumi.Input<string>;
}

export interface ServiceMaintainer {
    /**
     * The id of the maintainer.
     */
    id: pulumi.Input<string>;
    /**
     * The type of the maintainer. (user, team or squad)
     */
    type: pulumi.Input<string>;
}

export interface ServiceMaintenanceWindow {
    /**
     * Starting Time
     */
    from: pulumi.Input<string>;
    /**
     * repeat frequency. ('day', 'week', '2 weeks', '3 weeks', 'month')
     */
    repeatFrequency?: pulumi.Input<string>;
    /**
     * Till when you want to repeat this Maintenance mode
     */
    repeatTill?: pulumi.Input<string>;
    /**
     * End Time.
     */
    till: pulumi.Input<string>;
}

export interface ServiceTag {
    /**
     * key
     */
    key: pulumi.Input<string>;
    /**
     * value
     */
    value: pulumi.Input<string>;
}

export interface SuppressionRulesRule {
    /**
     * The basic expression which needs to be evaluated to be true for this rule to apply.
     */
    basicExpressions?: pulumi.Input<pulumi.Input<inputs.SuppressionRulesRuleBasicExpression>[]>;
    /**
     * description.
     */
    description?: pulumi.Input<string>;
    /**
     * The expression which needs to be evaluated to be true for this rule to apply.
     */
    expression?: pulumi.Input<string>;
    /**
     * is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
     */
    isBasic: pulumi.Input<boolean>;
    /**
     * is_timebased will be true when users use the time based suppression rule
     */
    isTimebased?: pulumi.Input<boolean>;
    /**
     * The timeslots for which this rule should be applied.
     */
    timeslots?: pulumi.Input<pulumi.Input<inputs.SuppressionRulesRuleTimeslot>[]>;
}

export interface SuppressionRulesRuleBasicExpression {
    lhs: pulumi.Input<string>;
    op: pulumi.Input<string>;
    rhs: pulumi.Input<string>;
}

export interface SuppressionRulesRuleTimeslot {
    customs?: pulumi.Input<pulumi.Input<inputs.SuppressionRulesRuleTimeslotCustom>[]>;
    endTime: pulumi.Input<string>;
    endsNever?: pulumi.Input<boolean>;
    endsOn: pulumi.Input<string>;
    isAllday?: pulumi.Input<boolean>;
    isCustom?: pulumi.Input<boolean>;
    repetition: pulumi.Input<string>;
    startTime: pulumi.Input<string>;
    timeZone: pulumi.Input<string>;
}

export interface SuppressionRulesRuleTimeslotCustom {
    repeats: pulumi.Input<string>;
    repeatsCount?: pulumi.Input<number>;
    repeatsOnMonth?: pulumi.Input<string>;
    repeatsOnWeekdays?: pulumi.Input<pulumi.Input<number>[]>;
}

export interface TaggingRulesRule {
    /**
     * The basic expression which needs to be evaluated to be true for this rule to apply.
     */
    basicExpressions?: pulumi.Input<pulumi.Input<inputs.TaggingRulesRuleBasicExpression>[]>;
    /**
     * The expression which needs to be evaluated to be true for this rule to apply.
     */
    expression?: pulumi.Input<string>;
    /**
     * is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
     */
    isBasic: pulumi.Input<boolean>;
    /**
     * The tags supposed to be set for a given payload(incident), Expression must be set when tags are empty and must contain addTags parameters.
     */
    tags?: pulumi.Input<pulumi.Input<inputs.TaggingRulesRuleTag>[]>;
}

export interface TaggingRulesRuleBasicExpression {
    lhs: pulumi.Input<string>;
    op: pulumi.Input<string>;
    rhs: pulumi.Input<string>;
}

export interface TaggingRulesRuleTag {
    color: pulumi.Input<string>;
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}
