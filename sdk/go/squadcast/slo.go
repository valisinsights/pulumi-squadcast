// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package squadcast

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/valisinsights/pulumi-squadcast/sdk/go/squadcast/internal"
)

// `SLO` manages an SLO.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/valisinsights/pulumi-squadcast/sdk/go/squadcast"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			exampleTeam, err := squadcast.LookupTeam(ctx, &squadcast.LookupTeamArgs{
//				Name: "example team name",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			exampleUser, err := squadcast.LookupUser(ctx, &squadcast.LookupUserArgs{
//				Email: "test@example.com",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			exampleService, err := squadcast.LookupService(ctx, &squadcast.LookupServiceArgs{
//				Name:   "example service name",
//				TeamId: exampleTeam.Id,
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = squadcast.NewSLO(ctx, "exampleSlo", &squadcast.SLOArgs{
//				TeamId:      *pulumi.String(exampleTeam.Id),
//				Description: pulumi.String("Slo for checkout flow"),
//				TargetSlo:   pulumi.Float64(99.99),
//				ServiceIds: pulumi.StringArray{
//					*pulumi.String(exampleService.Id),
//				},
//				Slis: pulumi.StringArray{
//					pulumi.String("latency"),
//					pulumi.String("high-err-rate"),
//				},
//				TimeIntervalType: pulumi.String("rolling"),
//				DurationInDays:   pulumi.Int(7),
//				Rules: squadcast.SLORuleArray{
//					&squadcast.SLORuleArgs{
//						Name: pulumi.String("breached_error_budget"),
//					},
//					&squadcast.SLORuleArgs{
//						Name:      pulumi.String("remaining_error_budget"),
//						Threshold: pulumi.Int(11),
//					},
//					&squadcast.SLORuleArgs{
//						Name:      pulumi.String("unhealthy_slo"),
//						Threshold: pulumi.Int(1),
//					},
//				},
//				Notify: &squadcast.SLONotifyArgs{
//					UserIds: pulumi.StringArray{
//						*pulumi.String(exampleUser.Id),
//					},
//				},
//				EntityOwner: &squadcast.SLOEntityOwnerArgs{
//					Id:   *pulumi.String(exampleUser.Id),
//					Type: pulumi.String("user"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// teamID:sloID Use 'Get All Teams' and 'Get All Slos' APIs to get the id of the team and slo respectively
//
// ```sh
//
//	$ pulumi import squadcast:index/sLO:SLO test 61443b953ffd52818bf1617a:1023
//
// ```
type SLO struct {
	pulumi.CustomResourceState

	// Description of the SLO.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Tracks SLO for the last x days. Required only when SLO time interval type set to "rolling"
	DurationInDays pulumi.IntOutput `pulumi:"durationInDays"`
	// SLO end time. Required only when SLO time interval type set to "fixed"
	EndTime pulumi.StringOutput `pulumi:"endTime"`
	// SLO owner.
	EntityOwner SLOEntityOwnerOutput `pulumi:"entityOwner"`
	// The name of the SLO.
	Name pulumi.StringOutput `pulumi:"name"`
	// Notification rules for SLO violationUser can either choose to create an incident or get alerted via email
	Notify SLONotifyPtrOutput `pulumi:"notify"`
	// SLO monitoring checks has rules for monitoring any SLO violation(Or warning signs)
	Rules SLORuleArrayOutput `pulumi:"rules"`
	// Service IDs associated with the SLO.Only incidents from the associated services can be promoted as SLO violating incident
	ServiceIds pulumi.StringArrayOutput `pulumi:"serviceIds"`
	// List of indentified SLIs for the SLO
	Slis pulumi.StringArrayOutput `pulumi:"slis"`
	// SLO start time. Required only when SLO time interval type set to "fixed"
	StartTime pulumi.StringOutput `pulumi:"startTime"`
	// The target SLO for the time period.
	TargetSlo pulumi.Float64Output `pulumi:"targetSlo"`
	// The team which SLO resource belongs to
	TeamId pulumi.StringOutput `pulumi:"teamId"`
	// Type of the SLO. Values can either be "rolling" or "fixed"
	TimeIntervalType pulumi.StringOutput `pulumi:"timeIntervalType"`
}

// NewSLO registers a new resource with the given unique name, arguments, and options.
func NewSLO(ctx *pulumi.Context,
	name string, args *SLOArgs, opts ...pulumi.ResourceOption) (*SLO, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ServiceIds == nil {
		return nil, errors.New("invalid value for required argument 'ServiceIds'")
	}
	if args.Slis == nil {
		return nil, errors.New("invalid value for required argument 'Slis'")
	}
	if args.TargetSlo == nil {
		return nil, errors.New("invalid value for required argument 'TargetSlo'")
	}
	if args.TeamId == nil {
		return nil, errors.New("invalid value for required argument 'TeamId'")
	}
	if args.TimeIntervalType == nil {
		return nil, errors.New("invalid value for required argument 'TimeIntervalType'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SLO
	err := ctx.RegisterResource("squadcast:index/sLO:SLO", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSLO gets an existing SLO resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSLO(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SLOState, opts ...pulumi.ResourceOption) (*SLO, error) {
	var resource SLO
	err := ctx.ReadResource("squadcast:index/sLO:SLO", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SLO resources.
type sloState struct {
	// Description of the SLO.
	Description *string `pulumi:"description"`
	// Tracks SLO for the last x days. Required only when SLO time interval type set to "rolling"
	DurationInDays *int `pulumi:"durationInDays"`
	// SLO end time. Required only when SLO time interval type set to "fixed"
	EndTime *string `pulumi:"endTime"`
	// SLO owner.
	EntityOwner *SLOEntityOwner `pulumi:"entityOwner"`
	// The name of the SLO.
	Name *string `pulumi:"name"`
	// Notification rules for SLO violationUser can either choose to create an incident or get alerted via email
	Notify *SLONotify `pulumi:"notify"`
	// SLO monitoring checks has rules for monitoring any SLO violation(Or warning signs)
	Rules []SLORule `pulumi:"rules"`
	// Service IDs associated with the SLO.Only incidents from the associated services can be promoted as SLO violating incident
	ServiceIds []string `pulumi:"serviceIds"`
	// List of indentified SLIs for the SLO
	Slis []string `pulumi:"slis"`
	// SLO start time. Required only when SLO time interval type set to "fixed"
	StartTime *string `pulumi:"startTime"`
	// The target SLO for the time period.
	TargetSlo *float64 `pulumi:"targetSlo"`
	// The team which SLO resource belongs to
	TeamId *string `pulumi:"teamId"`
	// Type of the SLO. Values can either be "rolling" or "fixed"
	TimeIntervalType *string `pulumi:"timeIntervalType"`
}

type SLOState struct {
	// Description of the SLO.
	Description pulumi.StringPtrInput
	// Tracks SLO for the last x days. Required only when SLO time interval type set to "rolling"
	DurationInDays pulumi.IntPtrInput
	// SLO end time. Required only when SLO time interval type set to "fixed"
	EndTime pulumi.StringPtrInput
	// SLO owner.
	EntityOwner SLOEntityOwnerPtrInput
	// The name of the SLO.
	Name pulumi.StringPtrInput
	// Notification rules for SLO violationUser can either choose to create an incident or get alerted via email
	Notify SLONotifyPtrInput
	// SLO monitoring checks has rules for monitoring any SLO violation(Or warning signs)
	Rules SLORuleArrayInput
	// Service IDs associated with the SLO.Only incidents from the associated services can be promoted as SLO violating incident
	ServiceIds pulumi.StringArrayInput
	// List of indentified SLIs for the SLO
	Slis pulumi.StringArrayInput
	// SLO start time. Required only when SLO time interval type set to "fixed"
	StartTime pulumi.StringPtrInput
	// The target SLO for the time period.
	TargetSlo pulumi.Float64PtrInput
	// The team which SLO resource belongs to
	TeamId pulumi.StringPtrInput
	// Type of the SLO. Values can either be "rolling" or "fixed"
	TimeIntervalType pulumi.StringPtrInput
}

func (SLOState) ElementType() reflect.Type {
	return reflect.TypeOf((*sloState)(nil)).Elem()
}

type sloArgs struct {
	// Description of the SLO.
	Description *string `pulumi:"description"`
	// Tracks SLO for the last x days. Required only when SLO time interval type set to "rolling"
	DurationInDays *int `pulumi:"durationInDays"`
	// SLO end time. Required only when SLO time interval type set to "fixed"
	EndTime *string `pulumi:"endTime"`
	// SLO owner.
	EntityOwner *SLOEntityOwner `pulumi:"entityOwner"`
	// The name of the SLO.
	Name *string `pulumi:"name"`
	// Notification rules for SLO violationUser can either choose to create an incident or get alerted via email
	Notify *SLONotify `pulumi:"notify"`
	// SLO monitoring checks has rules for monitoring any SLO violation(Or warning signs)
	Rules []SLORule `pulumi:"rules"`
	// Service IDs associated with the SLO.Only incidents from the associated services can be promoted as SLO violating incident
	ServiceIds []string `pulumi:"serviceIds"`
	// List of indentified SLIs for the SLO
	Slis []string `pulumi:"slis"`
	// SLO start time. Required only when SLO time interval type set to "fixed"
	StartTime *string `pulumi:"startTime"`
	// The target SLO for the time period.
	TargetSlo float64 `pulumi:"targetSlo"`
	// The team which SLO resource belongs to
	TeamId string `pulumi:"teamId"`
	// Type of the SLO. Values can either be "rolling" or "fixed"
	TimeIntervalType string `pulumi:"timeIntervalType"`
}

// The set of arguments for constructing a SLO resource.
type SLOArgs struct {
	// Description of the SLO.
	Description pulumi.StringPtrInput
	// Tracks SLO for the last x days. Required only when SLO time interval type set to "rolling"
	DurationInDays pulumi.IntPtrInput
	// SLO end time. Required only when SLO time interval type set to "fixed"
	EndTime pulumi.StringPtrInput
	// SLO owner.
	EntityOwner SLOEntityOwnerPtrInput
	// The name of the SLO.
	Name pulumi.StringPtrInput
	// Notification rules for SLO violationUser can either choose to create an incident or get alerted via email
	Notify SLONotifyPtrInput
	// SLO monitoring checks has rules for monitoring any SLO violation(Or warning signs)
	Rules SLORuleArrayInput
	// Service IDs associated with the SLO.Only incidents from the associated services can be promoted as SLO violating incident
	ServiceIds pulumi.StringArrayInput
	// List of indentified SLIs for the SLO
	Slis pulumi.StringArrayInput
	// SLO start time. Required only when SLO time interval type set to "fixed"
	StartTime pulumi.StringPtrInput
	// The target SLO for the time period.
	TargetSlo pulumi.Float64Input
	// The team which SLO resource belongs to
	TeamId pulumi.StringInput
	// Type of the SLO. Values can either be "rolling" or "fixed"
	TimeIntervalType pulumi.StringInput
}

func (SLOArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*sloArgs)(nil)).Elem()
}

type SLOInput interface {
	pulumi.Input

	ToSLOOutput() SLOOutput
	ToSLOOutputWithContext(ctx context.Context) SLOOutput
}

func (*SLO) ElementType() reflect.Type {
	return reflect.TypeOf((**SLO)(nil)).Elem()
}

func (i *SLO) ToSLOOutput() SLOOutput {
	return i.ToSLOOutputWithContext(context.Background())
}

func (i *SLO) ToSLOOutputWithContext(ctx context.Context) SLOOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SLOOutput)
}

// SLOArrayInput is an input type that accepts SLOArray and SLOArrayOutput values.
// You can construct a concrete instance of `SLOArrayInput` via:
//
//	SLOArray{ SLOArgs{...} }
type SLOArrayInput interface {
	pulumi.Input

	ToSLOArrayOutput() SLOArrayOutput
	ToSLOArrayOutputWithContext(context.Context) SLOArrayOutput
}

type SLOArray []SLOInput

func (SLOArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SLO)(nil)).Elem()
}

func (i SLOArray) ToSLOArrayOutput() SLOArrayOutput {
	return i.ToSLOArrayOutputWithContext(context.Background())
}

func (i SLOArray) ToSLOArrayOutputWithContext(ctx context.Context) SLOArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SLOArrayOutput)
}

// SLOMapInput is an input type that accepts SLOMap and SLOMapOutput values.
// You can construct a concrete instance of `SLOMapInput` via:
//
//	SLOMap{ "key": SLOArgs{...} }
type SLOMapInput interface {
	pulumi.Input

	ToSLOMapOutput() SLOMapOutput
	ToSLOMapOutputWithContext(context.Context) SLOMapOutput
}

type SLOMap map[string]SLOInput

func (SLOMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SLO)(nil)).Elem()
}

func (i SLOMap) ToSLOMapOutput() SLOMapOutput {
	return i.ToSLOMapOutputWithContext(context.Background())
}

func (i SLOMap) ToSLOMapOutputWithContext(ctx context.Context) SLOMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SLOMapOutput)
}

type SLOOutput struct{ *pulumi.OutputState }

func (SLOOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SLO)(nil)).Elem()
}

func (o SLOOutput) ToSLOOutput() SLOOutput {
	return o
}

func (o SLOOutput) ToSLOOutputWithContext(ctx context.Context) SLOOutput {
	return o
}

// Description of the SLO.
func (o SLOOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SLO) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Tracks SLO for the last x days. Required only when SLO time interval type set to "rolling"
func (o SLOOutput) DurationInDays() pulumi.IntOutput {
	return o.ApplyT(func(v *SLO) pulumi.IntOutput { return v.DurationInDays }).(pulumi.IntOutput)
}

// SLO end time. Required only when SLO time interval type set to "fixed"
func (o SLOOutput) EndTime() pulumi.StringOutput {
	return o.ApplyT(func(v *SLO) pulumi.StringOutput { return v.EndTime }).(pulumi.StringOutput)
}

// SLO owner.
func (o SLOOutput) EntityOwner() SLOEntityOwnerOutput {
	return o.ApplyT(func(v *SLO) SLOEntityOwnerOutput { return v.EntityOwner }).(SLOEntityOwnerOutput)
}

// The name of the SLO.
func (o SLOOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *SLO) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Notification rules for SLO violationUser can either choose to create an incident or get alerted via email
func (o SLOOutput) Notify() SLONotifyPtrOutput {
	return o.ApplyT(func(v *SLO) SLONotifyPtrOutput { return v.Notify }).(SLONotifyPtrOutput)
}

// SLO monitoring checks has rules for monitoring any SLO violation(Or warning signs)
func (o SLOOutput) Rules() SLORuleArrayOutput {
	return o.ApplyT(func(v *SLO) SLORuleArrayOutput { return v.Rules }).(SLORuleArrayOutput)
}

// Service IDs associated with the SLO.Only incidents from the associated services can be promoted as SLO violating incident
func (o SLOOutput) ServiceIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SLO) pulumi.StringArrayOutput { return v.ServiceIds }).(pulumi.StringArrayOutput)
}

// List of indentified SLIs for the SLO
func (o SLOOutput) Slis() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SLO) pulumi.StringArrayOutput { return v.Slis }).(pulumi.StringArrayOutput)
}

// SLO start time. Required only when SLO time interval type set to "fixed"
func (o SLOOutput) StartTime() pulumi.StringOutput {
	return o.ApplyT(func(v *SLO) pulumi.StringOutput { return v.StartTime }).(pulumi.StringOutput)
}

// The target SLO for the time period.
func (o SLOOutput) TargetSlo() pulumi.Float64Output {
	return o.ApplyT(func(v *SLO) pulumi.Float64Output { return v.TargetSlo }).(pulumi.Float64Output)
}

// The team which SLO resource belongs to
func (o SLOOutput) TeamId() pulumi.StringOutput {
	return o.ApplyT(func(v *SLO) pulumi.StringOutput { return v.TeamId }).(pulumi.StringOutput)
}

// Type of the SLO. Values can either be "rolling" or "fixed"
func (o SLOOutput) TimeIntervalType() pulumi.StringOutput {
	return o.ApplyT(func(v *SLO) pulumi.StringOutput { return v.TimeIntervalType }).(pulumi.StringOutput)
}

type SLOArrayOutput struct{ *pulumi.OutputState }

func (SLOArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SLO)(nil)).Elem()
}

func (o SLOArrayOutput) ToSLOArrayOutput() SLOArrayOutput {
	return o
}

func (o SLOArrayOutput) ToSLOArrayOutputWithContext(ctx context.Context) SLOArrayOutput {
	return o
}

func (o SLOArrayOutput) Index(i pulumi.IntInput) SLOOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SLO {
		return vs[0].([]*SLO)[vs[1].(int)]
	}).(SLOOutput)
}

type SLOMapOutput struct{ *pulumi.OutputState }

func (SLOMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SLO)(nil)).Elem()
}

func (o SLOMapOutput) ToSLOMapOutput() SLOMapOutput {
	return o
}

func (o SLOMapOutput) ToSLOMapOutputWithContext(ctx context.Context) SLOMapOutput {
	return o
}

func (o SLOMapOutput) MapIndex(k pulumi.StringInput) SLOOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SLO {
		return vs[0].(map[string]*SLO)[vs[1].(string)]
	}).(SLOOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SLOInput)(nil)).Elem(), &SLO{})
	pulumi.RegisterInputType(reflect.TypeOf((*SLOArrayInput)(nil)).Elem(), SLOArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SLOMapInput)(nil)).Elem(), SLOMap{})
	pulumi.RegisterOutputType(SLOOutput{})
	pulumi.RegisterOutputType(SLOArrayOutput{})
	pulumi.RegisterOutputType(SLOMapOutput{})
}
