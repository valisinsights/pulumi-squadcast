# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'DeduplicationRulesRuleArgs',
    'DeduplicationRulesRuleBasicExpressionArgs',
    'EscalationPolicyEntityOwnerArgs',
    'EscalationPolicyRepeatArgs',
    'EscalationPolicyRuleArgs',
    'EscalationPolicyRuleRepeatArgs',
    'EscalationPolicyRuleRoundRobinArgs',
    'EscalationPolicyRuleRoundRobinRotationArgs',
    'EscalationPolicyRuleTargetArgs',
    'RoutingRulesRuleArgs',
    'RoutingRulesRuleBasicExpressionArgs',
    'RunbookEntityOwnerArgs',
    'RunbookStepArgs',
    'SLOEntityOwnerArgs',
    'SLONotifyArgs',
    'SLORuleArgs',
    'ScheduleRotationV2ParticipantGroupArgs',
    'ScheduleRotationV2ParticipantGroupParticipantArgs',
    'ScheduleRotationV2ShiftTimeslotArgs',
    'ScheduleV2EntityOwnerArgs',
    'ScheduleV2TagArgs',
    'SebformInputFieldArgs',
    'SebformOwnerArgs',
    'SebformServiceArgs',
    'SebformSeverityArgs',
    'ServiceMaintainerArgs',
    'ServiceMaintenanceWindowArgs',
    'ServiceTagArgs',
    'SuppressionRulesRuleArgs',
    'SuppressionRulesRuleBasicExpressionArgs',
    'SuppressionRulesRuleTimeslotArgs',
    'SuppressionRulesRuleTimeslotCustomArgs',
    'TaggingRulesRuleArgs',
    'TaggingRulesRuleBasicExpressionArgs',
    'TaggingRulesRuleTagArgs',
]

@pulumi.input_type
class DeduplicationRulesRuleArgs:
    def __init__(__self__, *,
                 is_basic: pulumi.Input[bool],
                 basic_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['DeduplicationRulesRuleBasicExpressionArgs']]]] = None,
                 dependency_deduplication: Optional[pulumi.Input[bool]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 time_unit: Optional[pulumi.Input[str]] = None,
                 time_window: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] is_basic: is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        :param pulumi.Input[Sequence[pulumi.Input['DeduplicationRulesRuleBasicExpressionArgs']]] basic_expressions: The basic expression which needs to be evaluated to be true for this rule to apply.
        :param pulumi.Input[bool] dependency_deduplication: Denotes if dependent services should also be deduplicated
        :param pulumi.Input[str] description: description.
        :param pulumi.Input[str] expression: The expression which needs to be evaluated to be true for this rule to apply.
        :param pulumi.Input[str] time_unit: time unit (mins or hours)
        :param pulumi.Input[int] time_window: integer for time_unit
        """
        pulumi.set(__self__, "is_basic", is_basic)
        if basic_expressions is not None:
            pulumi.set(__self__, "basic_expressions", basic_expressions)
        if dependency_deduplication is not None:
            pulumi.set(__self__, "dependency_deduplication", dependency_deduplication)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)
        if time_window is not None:
            pulumi.set(__self__, "time_window", time_window)

    @property
    @pulumi.getter(name="isBasic")
    def is_basic(self) -> pulumi.Input[bool]:
        """
        is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        """
        return pulumi.get(self, "is_basic")

    @is_basic.setter
    def is_basic(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_basic", value)

    @property
    @pulumi.getter(name="basicExpressions")
    def basic_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeduplicationRulesRuleBasicExpressionArgs']]]]:
        """
        The basic expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "basic_expressions")

    @basic_expressions.setter
    def basic_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeduplicationRulesRuleBasicExpressionArgs']]]]):
        pulumi.set(self, "basic_expressions", value)

    @property
    @pulumi.getter(name="dependencyDeduplication")
    def dependency_deduplication(self) -> Optional[pulumi.Input[bool]]:
        """
        Denotes if dependent services should also be deduplicated
        """
        return pulumi.get(self, "dependency_deduplication")

    @dependency_deduplication.setter
    def dependency_deduplication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dependency_deduplication", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        The expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[pulumi.Input[str]]:
        """
        time unit (mins or hours)
        """
        return pulumi.get(self, "time_unit")

    @time_unit.setter
    def time_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_unit", value)

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> Optional[pulumi.Input[int]]:
        """
        integer for time_unit
        """
        return pulumi.get(self, "time_window")

    @time_window.setter
    def time_window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_window", value)


@pulumi.input_type
class DeduplicationRulesRuleBasicExpressionArgs:
    def __init__(__self__, *,
                 lhs: pulumi.Input[str],
                 op: pulumi.Input[str],
                 rhs: pulumi.Input[str]):
        pulumi.set(__self__, "lhs", lhs)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "rhs", rhs)

    @property
    @pulumi.getter
    def lhs(self) -> pulumi.Input[str]:
        return pulumi.get(self, "lhs")

    @lhs.setter
    def lhs(self, value: pulumi.Input[str]):
        pulumi.set(self, "lhs", value)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def rhs(self) -> pulumi.Input[str]:
        return pulumi.get(self, "rhs")

    @rhs.setter
    def rhs(self, value: pulumi.Input[str]):
        pulumi.set(self, "rhs", value)


@pulumi.input_type
class EscalationPolicyEntityOwnerArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: Escalation policy owner id.
        :param pulumi.Input[str] type: Escalation policy owner type. (user or squad or team)
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Escalation policy owner id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Escalation policy owner type. (user or squad or team)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class EscalationPolicyRepeatArgs:
    def __init__(__self__, *,
                 delay_minutes: pulumi.Input[int],
                 times: pulumi.Input[int]):
        """
        :param pulumi.Input[int] delay_minutes: The number of minutes to wait before repeating the escalation policy
        :param pulumi.Input[int] times: The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
        """
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "times", times)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> pulumi.Input[int]:
        """
        The number of minutes to wait before repeating the escalation policy
        """
        return pulumi.get(self, "delay_minutes")

    @delay_minutes.setter
    def delay_minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "delay_minutes", value)

    @property
    @pulumi.getter
    def times(self) -> pulumi.Input[int]:
        """
        The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
        """
        return pulumi.get(self, "times")

    @times.setter
    def times(self, value: pulumi.Input[int]):
        pulumi.set(self, "times", value)


@pulumi.input_type
class EscalationPolicyRuleArgs:
    def __init__(__self__, *,
                 delay_minutes: pulumi.Input[int],
                 targets: pulumi.Input[Sequence[pulumi.Input['EscalationPolicyRuleTargetArgs']]],
                 notification_channels: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 repeat: Optional[pulumi.Input['EscalationPolicyRuleRepeatArgs']] = None,
                 round_robin: Optional[pulumi.Input['EscalationPolicyRuleRoundRobinArgs']] = None):
        """
        :param pulumi.Input['EscalationPolicyRuleRepeatArgs'] repeat: repeat this rule
        """
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "targets", targets)
        if notification_channels is not None:
            pulumi.set(__self__, "notification_channels", notification_channels)
        if repeat is not None:
            pulumi.set(__self__, "repeat", repeat)
        if round_robin is not None:
            pulumi.set(__self__, "round_robin", round_robin)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> pulumi.Input[int]:
        return pulumi.get(self, "delay_minutes")

    @delay_minutes.setter
    def delay_minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "delay_minutes", value)

    @property
    @pulumi.getter
    def targets(self) -> pulumi.Input[Sequence[pulumi.Input['EscalationPolicyRuleTargetArgs']]]:
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: pulumi.Input[Sequence[pulumi.Input['EscalationPolicyRuleTargetArgs']]]):
        pulumi.set(self, "targets", value)

    @property
    @pulumi.getter(name="notificationChannels")
    def notification_channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "notification_channels")

    @notification_channels.setter
    def notification_channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "notification_channels", value)

    @property
    @pulumi.getter
    def repeat(self) -> Optional[pulumi.Input['EscalationPolicyRuleRepeatArgs']]:
        """
        repeat this rule
        """
        return pulumi.get(self, "repeat")

    @repeat.setter
    def repeat(self, value: Optional[pulumi.Input['EscalationPolicyRuleRepeatArgs']]):
        pulumi.set(self, "repeat", value)

    @property
    @pulumi.getter(name="roundRobin")
    def round_robin(self) -> Optional[pulumi.Input['EscalationPolicyRuleRoundRobinArgs']]:
        return pulumi.get(self, "round_robin")

    @round_robin.setter
    def round_robin(self, value: Optional[pulumi.Input['EscalationPolicyRuleRoundRobinArgs']]):
        pulumi.set(self, "round_robin", value)


@pulumi.input_type
class EscalationPolicyRuleRepeatArgs:
    def __init__(__self__, *,
                 delay_minutes: pulumi.Input[int],
                 times: pulumi.Input[int]):
        """
        :param pulumi.Input[int] delay_minutes: The number of minutes to wait before repeating the escalation policy
        :param pulumi.Input[int] times: The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
        """
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "times", times)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> pulumi.Input[int]:
        """
        The number of minutes to wait before repeating the escalation policy
        """
        return pulumi.get(self, "delay_minutes")

    @delay_minutes.setter
    def delay_minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "delay_minutes", value)

    @property
    @pulumi.getter
    def times(self) -> pulumi.Input[int]:
        """
        The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
        """
        return pulumi.get(self, "times")

    @times.setter
    def times(self, value: pulumi.Input[int]):
        pulumi.set(self, "times", value)


@pulumi.input_type
class EscalationPolicyRuleRoundRobinArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 rotation: Optional[pulumi.Input['EscalationPolicyRuleRoundRobinRotationArgs']] = None):
        pulumi.set(__self__, "enabled", enabled)
        if rotation is not None:
            pulumi.set(__self__, "rotation", rotation)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def rotation(self) -> Optional[pulumi.Input['EscalationPolicyRuleRoundRobinRotationArgs']]:
        return pulumi.get(self, "rotation")

    @rotation.setter
    def rotation(self, value: Optional[pulumi.Input['EscalationPolicyRuleRoundRobinRotationArgs']]):
        pulumi.set(self, "rotation", value)


@pulumi.input_type
class EscalationPolicyRuleRoundRobinRotationArgs:
    def __init__(__self__, *,
                 delay_minutes: Optional[pulumi.Input[int]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if delay_minutes is not None:
            pulumi.set(__self__, "delay_minutes", delay_minutes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "delay_minutes")

    @delay_minutes.setter
    def delay_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "delay_minutes", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class EscalationPolicyRuleTargetArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: EscalationPolicy id.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        EscalationPolicy id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RoutingRulesRuleArgs:
    def __init__(__self__, *,
                 is_basic: pulumi.Input[bool],
                 route_to_id: pulumi.Input[str],
                 route_to_type: pulumi.Input[str],
                 basic_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['RoutingRulesRuleBasicExpressionArgs']]]] = None,
                 expression: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] is_basic: is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        :param pulumi.Input[str] route_to_id: The id of the entity (user, escalation policy, squad) for which we are routing this incident.
        :param pulumi.Input[str] route_to_type: Type of the entity for which we are routing this incident - User, Escalation Policy or Squad
        :param pulumi.Input[Sequence[pulumi.Input['RoutingRulesRuleBasicExpressionArgs']]] basic_expressions: The basic expression which needs to be evaluated to be true for this rule to apply.
        :param pulumi.Input[str] expression: The expression which needs to be evaluated to be true for this rule to apply.
        """
        pulumi.set(__self__, "is_basic", is_basic)
        pulumi.set(__self__, "route_to_id", route_to_id)
        pulumi.set(__self__, "route_to_type", route_to_type)
        if basic_expressions is not None:
            pulumi.set(__self__, "basic_expressions", basic_expressions)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="isBasic")
    def is_basic(self) -> pulumi.Input[bool]:
        """
        is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        """
        return pulumi.get(self, "is_basic")

    @is_basic.setter
    def is_basic(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_basic", value)

    @property
    @pulumi.getter(name="routeToId")
    def route_to_id(self) -> pulumi.Input[str]:
        """
        The id of the entity (user, escalation policy, squad) for which we are routing this incident.
        """
        return pulumi.get(self, "route_to_id")

    @route_to_id.setter
    def route_to_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "route_to_id", value)

    @property
    @pulumi.getter(name="routeToType")
    def route_to_type(self) -> pulumi.Input[str]:
        """
        Type of the entity for which we are routing this incident - User, Escalation Policy or Squad
        """
        return pulumi.get(self, "route_to_type")

    @route_to_type.setter
    def route_to_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "route_to_type", value)

    @property
    @pulumi.getter(name="basicExpressions")
    def basic_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RoutingRulesRuleBasicExpressionArgs']]]]:
        """
        The basic expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "basic_expressions")

    @basic_expressions.setter
    def basic_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RoutingRulesRuleBasicExpressionArgs']]]]):
        pulumi.set(self, "basic_expressions", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        The expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)


@pulumi.input_type
class RoutingRulesRuleBasicExpressionArgs:
    def __init__(__self__, *,
                 lhs: pulumi.Input[str],
                 rhs: pulumi.Input[str]):
        pulumi.set(__self__, "lhs", lhs)
        pulumi.set(__self__, "rhs", rhs)

    @property
    @pulumi.getter
    def lhs(self) -> pulumi.Input[str]:
        return pulumi.get(self, "lhs")

    @lhs.setter
    def lhs(self, value: pulumi.Input[str]):
        pulumi.set(self, "lhs", value)

    @property
    @pulumi.getter
    def rhs(self) -> pulumi.Input[str]:
        return pulumi.get(self, "rhs")

    @rhs.setter
    def rhs(self, value: pulumi.Input[str]):
        pulumi.set(self, "rhs", value)


@pulumi.input_type
class RunbookEntityOwnerArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: Runbook owner id.
        :param pulumi.Input[str] type: Runbook owner type. (user or squad or team)
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Runbook owner id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Runbook owner type. (user or squad or team)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RunbookStepArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str]):
        pulumi.set(__self__, "content", content)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)


@pulumi.input_type
class SLOEntityOwnerArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: SLO owner id.
        :param pulumi.Input[str] type: SLO owner type (user, team, squad).
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        SLO owner id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        SLO owner type (user, team, squad).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class SLONotifyArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[int]] = None,
                 service_id: Optional[pulumi.Input[str]] = None,
                 slo_id: Optional[pulumi.Input[int]] = None,
                 squad_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] id: The ID of the notification rule
        :param pulumi.Input[str] service_id: The ID of the service in which the user want to create an incident
        :param pulumi.Input[int] slo_id: The ID of the SLO.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] squad_ids: List of Squad ID's who should be alerted via email.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] user_ids: List of user ID's who should be alerted via email.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)
        if slo_id is not None:
            pulumi.set(__self__, "slo_id", slo_id)
        if squad_ids is not None:
            pulumi.set(__self__, "squad_ids", squad_ids)
        if user_ids is not None:
            pulumi.set(__self__, "user_ids", user_ids)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the notification rule
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the service in which the user want to create an incident
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_id", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the SLO.
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter(name="squadIds")
    def squad_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Squad ID's who should be alerted via email.
        """
        return pulumi.get(self, "squad_ids")

    @squad_ids.setter
    def squad_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "squad_ids", value)

    @property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of user ID's who should be alerted via email.
        """
        return pulumi.get(self, "user_ids")

    @user_ids.setter
    def user_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "user_ids", value)


@pulumi.input_type
class SLORuleArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 id: Optional[pulumi.Input[int]] = None,
                 is_checked: Optional[pulumi.Input[bool]] = None,
                 slo_id: Optional[pulumi.Input[int]] = None,
                 threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: The name of monitoring check."Supported values are "breached*error*budget", "unhealthy*slo","increased*false*positives", "remaining*error_budget"
        :param pulumi.Input[int] id: The ID of the monitoring rule
        :param pulumi.Input[bool] is_checked: Is checked?
        :param pulumi.Input[int] slo_id: The ID of the SLO
        :param pulumi.Input[int] threshold: Threshold for the monitoring checkOnly supported for rules name "increased*false*positives" and "remaining*error*budget"
        """
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_checked is not None:
            pulumi.set(__self__, "is_checked", is_checked)
        if slo_id is not None:
            pulumi.set(__self__, "slo_id", slo_id)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of monitoring check."Supported values are "breached*error*budget", "unhealthy*slo","increased*false*positives", "remaining*error_budget"
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the monitoring rule
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="isChecked")
    def is_checked(self) -> Optional[pulumi.Input[bool]]:
        """
        Is checked?
        """
        return pulumi.get(self, "is_checked")

    @is_checked.setter
    def is_checked(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_checked", value)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the SLO
        """
        return pulumi.get(self, "slo_id")

    @slo_id.setter
    def slo_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "slo_id", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[int]]:
        """
        Threshold for the monitoring checkOnly supported for rules name "increased*false*positives" and "remaining*error*budget"
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threshold", value)


@pulumi.input_type
class ScheduleRotationV2ParticipantGroupArgs:
    def __init__(__self__, *,
                 participants: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleRotationV2ParticipantGroupParticipantArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ScheduleRotationV2ParticipantGroupParticipantArgs']]] participants: Group participants.
        """
        if participants is not None:
            pulumi.set(__self__, "participants", participants)

    @property
    @pulumi.getter
    def participants(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleRotationV2ParticipantGroupParticipantArgs']]]]:
        """
        Group participants.
        """
        return pulumi.get(self, "participants")

    @participants.setter
    def participants(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleRotationV2ParticipantGroupParticipantArgs']]]]):
        pulumi.set(self, "participants", value)


@pulumi.input_type
class ScheduleRotationV2ParticipantGroupParticipantArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: Rotation id.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Rotation id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ScheduleRotationV2ShiftTimeslotArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[int],
                 start_hour: pulumi.Input[int],
                 start_minute: pulumi.Input[int],
                 day_of_week: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] duration: Defines the duration of each shift. (in minutes)
        :param pulumi.Input[int] start_hour: Defines the start hour of the each shift in the schedule timezone.
        :param pulumi.Input[int] start_minute: Defines the start minute of the each shift in the schedule timezone.
        :param pulumi.Input[str] day_of_week: Defines the day of the week for the shift. If not specified, the timeslot is active on all days of the week.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_hour", start_hour)
        pulumi.set(__self__, "start_minute", start_minute)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[int]:
        """
        Defines the duration of each shift. (in minutes)
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[int]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> pulumi.Input[int]:
        """
        Defines the start hour of the each shift in the schedule timezone.
        """
        return pulumi.get(self, "start_hour")

    @start_hour.setter
    def start_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_hour", value)

    @property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> pulumi.Input[int]:
        """
        Defines the start minute of the each shift in the schedule timezone.
        """
        return pulumi.get(self, "start_minute")

    @start_minute.setter
    def start_minute(self, value: pulumi.Input[int]):
        pulumi.set(self, "start_minute", value)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[pulumi.Input[str]]:
        """
        Defines the day of the week for the shift. If not specified, the timeslot is active on all days of the week.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week", value)


@pulumi.input_type
class ScheduleV2EntityOwnerArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: Schedule owner id.
        :param pulumi.Input[str] type: Schedule owner type (user, team, squad).
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Schedule owner id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Schedule owner type (user, team, squad).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ScheduleV2TagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str],
                 color: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Schedule tag key.
        :param pulumi.Input[str] value: Schedule tag value.
        :param pulumi.Input[str] color: Schedule tag color.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if color is not None:
            pulumi.set(__self__, "color", color)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Schedule tag key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Schedule tag value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def color(self) -> Optional[pulumi.Input[str]]:
        """
        Schedule tag color.
        """
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "color", value)


@pulumi.input_type
class SebformInputFieldArgs:
    def __init__(__self__, *,
                 label: Optional[pulumi.Input[str]] = None,
                 options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] label: Input field Label.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] options: Input field options.
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Input field Label.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Input field options.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "options", value)


@pulumi.input_type
class SebformOwnerArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Form owner id.
        :param pulumi.Input[str] type: Form owner type (user, team, squad).
        :param pulumi.Input[str] name: Form owner name.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Form owner id.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Form owner type (user, team, squad).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Form owner name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class SebformServiceArgs:
    def __init__(__self__, *,
                 service_id: pulumi.Input[str],
                 alias: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service_id: Service ID.
        :param pulumi.Input[str] alias: Service alias.
        :param pulumi.Input[str] name: Service name.
        """
        pulumi.set(__self__, "service_id", service_id)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> pulumi.Input[str]:
        """
        Service ID.
        """
        return pulumi.get(self, "service_id")

    @service_id.setter
    def service_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_id", value)

    @property
    @pulumi.getter
    def alias(self) -> Optional[pulumi.Input[str]]:
        """
        Service alias.
        """
        return pulumi.get(self, "alias")

    @alias.setter
    def alias(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alias", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Service name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class SebformSeverityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Severity type.
        :param pulumi.Input[str] description: Severity description.
        """
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Severity type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Severity description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class ServiceMaintainerArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The id of the maintainer.
        :param pulumi.Input[str] type: The type of the maintainer. (user, team or squad)
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The id of the maintainer.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the maintainer. (user, team or squad)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ServiceMaintenanceWindowArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[str],
                 till: pulumi.Input[str],
                 repeat_frequency: Optional[pulumi.Input[str]] = None,
                 repeat_till: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] from_: Starting Time
        :param pulumi.Input[str] till: End Time.
        :param pulumi.Input[str] repeat_frequency: repeat frequency. ('day', 'week', '2 weeks', '3 weeks', 'month')
        :param pulumi.Input[str] repeat_till: Till when you want to repeat this Maintenance mode
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "till", till)
        if repeat_frequency is not None:
            pulumi.set(__self__, "repeat_frequency", repeat_frequency)
        if repeat_till is not None:
            pulumi.set(__self__, "repeat_till", repeat_till)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[str]:
        """
        Starting Time
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[str]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def till(self) -> pulumi.Input[str]:
        """
        End Time.
        """
        return pulumi.get(self, "till")

    @till.setter
    def till(self, value: pulumi.Input[str]):
        pulumi.set(self, "till", value)

    @property
    @pulumi.getter(name="repeatFrequency")
    def repeat_frequency(self) -> Optional[pulumi.Input[str]]:
        """
        repeat frequency. ('day', 'week', '2 weeks', '3 weeks', 'month')
        """
        return pulumi.get(self, "repeat_frequency")

    @repeat_frequency.setter
    def repeat_frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_frequency", value)

    @property
    @pulumi.getter(name="repeatTill")
    def repeat_till(self) -> Optional[pulumi.Input[str]]:
        """
        Till when you want to repeat this Maintenance mode
        """
        return pulumi.get(self, "repeat_till")

    @repeat_till.setter
    def repeat_till(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeat_till", value)


@pulumi.input_type
class ServiceTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: key
        :param pulumi.Input[str] value: value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        key
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        value
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class SuppressionRulesRuleArgs:
    def __init__(__self__, *,
                 is_basic: pulumi.Input[bool],
                 basic_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['SuppressionRulesRuleBasicExpressionArgs']]]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 is_timebased: Optional[pulumi.Input[bool]] = None,
                 timeslots: Optional[pulumi.Input[Sequence[pulumi.Input['SuppressionRulesRuleTimeslotArgs']]]] = None):
        """
        :param pulumi.Input[bool] is_basic: is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        :param pulumi.Input[Sequence[pulumi.Input['SuppressionRulesRuleBasicExpressionArgs']]] basic_expressions: The basic expression which needs to be evaluated to be true for this rule to apply.
        :param pulumi.Input[str] description: description.
        :param pulumi.Input[str] expression: The expression which needs to be evaluated to be true for this rule to apply.
        :param pulumi.Input[bool] is_timebased: is_timebased will be true when users use the time based suppression rule
        :param pulumi.Input[Sequence[pulumi.Input['SuppressionRulesRuleTimeslotArgs']]] timeslots: The timeslots for which this rule should be applied.
        """
        pulumi.set(__self__, "is_basic", is_basic)
        if basic_expressions is not None:
            pulumi.set(__self__, "basic_expressions", basic_expressions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if is_timebased is not None:
            pulumi.set(__self__, "is_timebased", is_timebased)
        if timeslots is not None:
            pulumi.set(__self__, "timeslots", timeslots)

    @property
    @pulumi.getter(name="isBasic")
    def is_basic(self) -> pulumi.Input[bool]:
        """
        is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        """
        return pulumi.get(self, "is_basic")

    @is_basic.setter
    def is_basic(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_basic", value)

    @property
    @pulumi.getter(name="basicExpressions")
    def basic_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SuppressionRulesRuleBasicExpressionArgs']]]]:
        """
        The basic expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "basic_expressions")

    @basic_expressions.setter
    def basic_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SuppressionRulesRuleBasicExpressionArgs']]]]):
        pulumi.set(self, "basic_expressions", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        The expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter(name="isTimebased")
    def is_timebased(self) -> Optional[pulumi.Input[bool]]:
        """
        is_timebased will be true when users use the time based suppression rule
        """
        return pulumi.get(self, "is_timebased")

    @is_timebased.setter
    def is_timebased(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_timebased", value)

    @property
    @pulumi.getter
    def timeslots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SuppressionRulesRuleTimeslotArgs']]]]:
        """
        The timeslots for which this rule should be applied.
        """
        return pulumi.get(self, "timeslots")

    @timeslots.setter
    def timeslots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SuppressionRulesRuleTimeslotArgs']]]]):
        pulumi.set(self, "timeslots", value)


@pulumi.input_type
class SuppressionRulesRuleBasicExpressionArgs:
    def __init__(__self__, *,
                 lhs: pulumi.Input[str],
                 op: pulumi.Input[str],
                 rhs: pulumi.Input[str]):
        pulumi.set(__self__, "lhs", lhs)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "rhs", rhs)

    @property
    @pulumi.getter
    def lhs(self) -> pulumi.Input[str]:
        return pulumi.get(self, "lhs")

    @lhs.setter
    def lhs(self, value: pulumi.Input[str]):
        pulumi.set(self, "lhs", value)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def rhs(self) -> pulumi.Input[str]:
        return pulumi.get(self, "rhs")

    @rhs.setter
    def rhs(self, value: pulumi.Input[str]):
        pulumi.set(self, "rhs", value)


@pulumi.input_type
class SuppressionRulesRuleTimeslotArgs:
    def __init__(__self__, *,
                 end_time: pulumi.Input[str],
                 ends_on: pulumi.Input[str],
                 repetition: pulumi.Input[str],
                 start_time: pulumi.Input[str],
                 time_zone: pulumi.Input[str],
                 customs: Optional[pulumi.Input[Sequence[pulumi.Input['SuppressionRulesRuleTimeslotCustomArgs']]]] = None,
                 ends_never: Optional[pulumi.Input[bool]] = None,
                 is_allday: Optional[pulumi.Input[bool]] = None,
                 is_custom: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "ends_on", ends_on)
        pulumi.set(__self__, "repetition", repetition)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if ends_never is not None:
            pulumi.set(__self__, "ends_never", ends_never)
        if is_allday is not None:
            pulumi.set(__self__, "is_allday", is_allday)
        if is_custom is not None:
            pulumi.set(__self__, "is_custom", is_custom)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="endsOn")
    def ends_on(self) -> pulumi.Input[str]:
        return pulumi.get(self, "ends_on")

    @ends_on.setter
    def ends_on(self, value: pulumi.Input[str]):
        pulumi.set(self, "ends_on", value)

    @property
    @pulumi.getter
    def repetition(self) -> pulumi.Input[str]:
        return pulumi.get(self, "repetition")

    @repetition.setter
    def repetition(self, value: pulumi.Input[str]):
        pulumi.set(self, "repetition", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[str]:
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter
    def customs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SuppressionRulesRuleTimeslotCustomArgs']]]]:
        return pulumi.get(self, "customs")

    @customs.setter
    def customs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SuppressionRulesRuleTimeslotCustomArgs']]]]):
        pulumi.set(self, "customs", value)

    @property
    @pulumi.getter(name="endsNever")
    def ends_never(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "ends_never")

    @ends_never.setter
    def ends_never(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ends_never", value)

    @property
    @pulumi.getter(name="isAllday")
    def is_allday(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_allday")

    @is_allday.setter
    def is_allday(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_allday", value)

    @property
    @pulumi.getter(name="isCustom")
    def is_custom(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_custom")

    @is_custom.setter
    def is_custom(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_custom", value)


@pulumi.input_type
class SuppressionRulesRuleTimeslotCustomArgs:
    def __init__(__self__, *,
                 repeats: pulumi.Input[str],
                 repeats_count: Optional[pulumi.Input[int]] = None,
                 repeats_on_month: Optional[pulumi.Input[str]] = None,
                 repeats_on_weekdays: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        pulumi.set(__self__, "repeats", repeats)
        if repeats_count is not None:
            pulumi.set(__self__, "repeats_count", repeats_count)
        if repeats_on_month is not None:
            pulumi.set(__self__, "repeats_on_month", repeats_on_month)
        if repeats_on_weekdays is not None:
            pulumi.set(__self__, "repeats_on_weekdays", repeats_on_weekdays)

    @property
    @pulumi.getter
    def repeats(self) -> pulumi.Input[str]:
        return pulumi.get(self, "repeats")

    @repeats.setter
    def repeats(self, value: pulumi.Input[str]):
        pulumi.set(self, "repeats", value)

    @property
    @pulumi.getter(name="repeatsCount")
    def repeats_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "repeats_count")

    @repeats_count.setter
    def repeats_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "repeats_count", value)

    @property
    @pulumi.getter(name="repeatsOnMonth")
    def repeats_on_month(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "repeats_on_month")

    @repeats_on_month.setter
    def repeats_on_month(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repeats_on_month", value)

    @property
    @pulumi.getter(name="repeatsOnWeekdays")
    def repeats_on_weekdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        return pulumi.get(self, "repeats_on_weekdays")

    @repeats_on_weekdays.setter
    def repeats_on_weekdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "repeats_on_weekdays", value)


@pulumi.input_type
class TaggingRulesRuleArgs:
    def __init__(__self__, *,
                 is_basic: pulumi.Input[bool],
                 basic_expressions: Optional[pulumi.Input[Sequence[pulumi.Input['TaggingRulesRuleBasicExpressionArgs']]]] = None,
                 expression: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['TaggingRulesRuleTagArgs']]]] = None):
        """
        :param pulumi.Input[bool] is_basic: is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        :param pulumi.Input[Sequence[pulumi.Input['TaggingRulesRuleBasicExpressionArgs']]] basic_expressions: The basic expression which needs to be evaluated to be true for this rule to apply.
        :param pulumi.Input[str] expression: The expression which needs to be evaluated to be true for this rule to apply.
        :param pulumi.Input[Sequence[pulumi.Input['TaggingRulesRuleTagArgs']]] tags: The tags supposed to be set for a given payload(incident), Expression must be set when tags are empty and must contain addTags parameters.
        """
        pulumi.set(__self__, "is_basic", is_basic)
        if basic_expressions is not None:
            pulumi.set(__self__, "basic_expressions", basic_expressions)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="isBasic")
    def is_basic(self) -> pulumi.Input[bool]:
        """
        is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        """
        return pulumi.get(self, "is_basic")

    @is_basic.setter
    def is_basic(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_basic", value)

    @property
    @pulumi.getter(name="basicExpressions")
    def basic_expressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaggingRulesRuleBasicExpressionArgs']]]]:
        """
        The basic expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "basic_expressions")

    @basic_expressions.setter
    def basic_expressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaggingRulesRuleBasicExpressionArgs']]]]):
        pulumi.set(self, "basic_expressions", value)

    @property
    @pulumi.getter
    def expression(self) -> Optional[pulumi.Input[str]]:
        """
        The expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TaggingRulesRuleTagArgs']]]]:
        """
        The tags supposed to be set for a given payload(incident), Expression must be set when tags are empty and must contain addTags parameters.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TaggingRulesRuleTagArgs']]]]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class TaggingRulesRuleBasicExpressionArgs:
    def __init__(__self__, *,
                 lhs: pulumi.Input[str],
                 op: pulumi.Input[str],
                 rhs: pulumi.Input[str]):
        pulumi.set(__self__, "lhs", lhs)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "rhs", rhs)

    @property
    @pulumi.getter
    def lhs(self) -> pulumi.Input[str]:
        return pulumi.get(self, "lhs")

    @lhs.setter
    def lhs(self, value: pulumi.Input[str]):
        pulumi.set(self, "lhs", value)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def rhs(self) -> pulumi.Input[str]:
        return pulumi.get(self, "rhs")

    @rhs.setter
    def rhs(self, value: pulumi.Input[str]):
        pulumi.set(self, "rhs", value)


@pulumi.input_type
class TaggingRulesRuleTagArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[str],
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "color", color)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def color(self) -> pulumi.Input[str]:
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


