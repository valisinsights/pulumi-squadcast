# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'DeduplicationRulesRule',
    'DeduplicationRulesRuleBasicExpression',
    'EscalationPolicyEntityOwner',
    'EscalationPolicyRepeat',
    'EscalationPolicyRule',
    'EscalationPolicyRuleRepeat',
    'EscalationPolicyRuleRoundRobin',
    'EscalationPolicyRuleRoundRobinRotation',
    'EscalationPolicyRuleTarget',
    'RoutingRulesRule',
    'RoutingRulesRuleBasicExpression',
    'RunbookEntityOwner',
    'RunbookStep',
    'SLOEntityOwner',
    'SLONotify',
    'SLORule',
    'ScheduleRotationV2ParticipantGroup',
    'ScheduleRotationV2ParticipantGroupParticipant',
    'ScheduleRotationV2ShiftTimeslot',
    'ScheduleV2EntityOwner',
    'ScheduleV2Tag',
    'SebformInputField',
    'SebformOwner',
    'SebformService',
    'SebformSeverity',
    'ServiceMaintainer',
    'ServiceMaintenanceWindow',
    'ServiceTag',
    'SuppressionRulesRule',
    'SuppressionRulesRuleBasicExpression',
    'SuppressionRulesRuleTimeslot',
    'SuppressionRulesRuleTimeslotCustom',
    'TaggingRulesRule',
    'TaggingRulesRuleBasicExpression',
    'TaggingRulesRuleTag',
    'GetEscalationPolicyEntityOwnerResult',
    'GetEscalationPolicyRepeatResult',
    'GetEscalationPolicyRuleResult',
    'GetEscalationPolicyRuleRepeatResult',
    'GetEscalationPolicyRuleRoundRobinResult',
    'GetEscalationPolicyRuleRoundRobinRotationResult',
    'GetEscalationPolicyRuleTargetResult',
    'GetRunbookEntityOwnerResult',
    'GetRunbookStepResult',
    'GetScheduleV2EntityOwnerResult',
    'GetScheduleV2TagResult',
    'GetServiceMaintainerResult',
    'GetServiceTagResult',
    'GetTeamMemberResult',
    'GetTeamRoleResult',
    'GetUserNotificationRuleResult',
    'GetUserOncallReminderRuleResult',
    'GetWebformInputFieldResult',
    'GetWebformOwnerResult',
    'GetWebformServiceResult',
    'GetWebformSeverityResult',
]

@pulumi.output_type
class DeduplicationRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isBasic":
            suggest = "is_basic"
        elif key == "basicExpressions":
            suggest = "basic_expressions"
        elif key == "dependencyDeduplication":
            suggest = "dependency_deduplication"
        elif key == "timeUnit":
            suggest = "time_unit"
        elif key == "timeWindow":
            suggest = "time_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeduplicationRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeduplicationRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeduplicationRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_basic: bool,
                 basic_expressions: Optional[Sequence['outputs.DeduplicationRulesRuleBasicExpression']] = None,
                 dependency_deduplication: Optional[bool] = None,
                 description: Optional[str] = None,
                 expression: Optional[str] = None,
                 time_unit: Optional[str] = None,
                 time_window: Optional[int] = None):
        """
        :param bool is_basic: is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        :param Sequence['DeduplicationRulesRuleBasicExpressionArgs'] basic_expressions: The basic expression which needs to be evaluated to be true for this rule to apply.
        :param bool dependency_deduplication: Denotes if dependent services should also be deduplicated
        :param str description: description.
        :param str expression: The expression which needs to be evaluated to be true for this rule to apply.
        :param str time_unit: time unit (mins or hours)
        :param int time_window: integer for time_unit
        """
        pulumi.set(__self__, "is_basic", is_basic)
        if basic_expressions is not None:
            pulumi.set(__self__, "basic_expressions", basic_expressions)
        if dependency_deduplication is not None:
            pulumi.set(__self__, "dependency_deduplication", dependency_deduplication)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)
        if time_window is not None:
            pulumi.set(__self__, "time_window", time_window)

    @property
    @pulumi.getter(name="isBasic")
    def is_basic(self) -> bool:
        """
        is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        """
        return pulumi.get(self, "is_basic")

    @property
    @pulumi.getter(name="basicExpressions")
    def basic_expressions(self) -> Optional[Sequence['outputs.DeduplicationRulesRuleBasicExpression']]:
        """
        The basic expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "basic_expressions")

    @property
    @pulumi.getter(name="dependencyDeduplication")
    def dependency_deduplication(self) -> Optional[bool]:
        """
        Denotes if dependent services should also be deduplicated
        """
        return pulumi.get(self, "dependency_deduplication")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        The expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[str]:
        """
        time unit (mins or hours)
        """
        return pulumi.get(self, "time_unit")

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> Optional[int]:
        """
        integer for time_unit
        """
        return pulumi.get(self, "time_window")


@pulumi.output_type
class DeduplicationRulesRuleBasicExpression(dict):
    def __init__(__self__, *,
                 lhs: str,
                 op: str,
                 rhs: str):
        pulumi.set(__self__, "lhs", lhs)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "rhs", rhs)

    @property
    @pulumi.getter
    def lhs(self) -> str:
        return pulumi.get(self, "lhs")

    @property
    @pulumi.getter
    def op(self) -> str:
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def rhs(self) -> str:
        return pulumi.get(self, "rhs")


@pulumi.output_type
class EscalationPolicyEntityOwner(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: Escalation policy owner id.
        :param str type: Escalation policy owner type. (user or squad or team)
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Escalation policy owner id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Escalation policy owner type. (user or squad or team)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EscalationPolicyRepeat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayMinutes":
            suggest = "delay_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EscalationPolicyRepeat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EscalationPolicyRepeat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EscalationPolicyRepeat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_minutes: int,
                 times: int):
        """
        :param int delay_minutes: The number of minutes to wait before repeating the escalation policy
        :param int times: The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
        """
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "times", times)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> int:
        """
        The number of minutes to wait before repeating the escalation policy
        """
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter
    def times(self) -> int:
        """
        The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class EscalationPolicyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayMinutes":
            suggest = "delay_minutes"
        elif key == "notificationChannels":
            suggest = "notification_channels"
        elif key == "roundRobin":
            suggest = "round_robin"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EscalationPolicyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EscalationPolicyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EscalationPolicyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_minutes: int,
                 targets: Sequence['outputs.EscalationPolicyRuleTarget'],
                 notification_channels: Optional[Sequence[str]] = None,
                 repeat: Optional['outputs.EscalationPolicyRuleRepeat'] = None,
                 round_robin: Optional['outputs.EscalationPolicyRuleRoundRobin'] = None):
        """
        :param 'EscalationPolicyRuleRepeatArgs' repeat: repeat this rule
        """
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "targets", targets)
        if notification_channels is not None:
            pulumi.set(__self__, "notification_channels", notification_channels)
        if repeat is not None:
            pulumi.set(__self__, "repeat", repeat)
        if round_robin is not None:
            pulumi.set(__self__, "round_robin", round_robin)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> int:
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.EscalationPolicyRuleTarget']:
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter(name="notificationChannels")
    def notification_channels(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "notification_channels")

    @property
    @pulumi.getter
    def repeat(self) -> Optional['outputs.EscalationPolicyRuleRepeat']:
        """
        repeat this rule
        """
        return pulumi.get(self, "repeat")

    @property
    @pulumi.getter(name="roundRobin")
    def round_robin(self) -> Optional['outputs.EscalationPolicyRuleRoundRobin']:
        return pulumi.get(self, "round_robin")


@pulumi.output_type
class EscalationPolicyRuleRepeat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayMinutes":
            suggest = "delay_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EscalationPolicyRuleRepeat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EscalationPolicyRuleRepeat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EscalationPolicyRuleRepeat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_minutes: int,
                 times: int):
        """
        :param int delay_minutes: The number of minutes to wait before repeating the escalation policy
        :param int times: The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
        """
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "times", times)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> int:
        """
        The number of minutes to wait before repeating the escalation policy
        """
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter
    def times(self) -> int:
        """
        The number of times you want this escalation policy to be repeated, maximum allowed to repeat 3 times
        """
        return pulumi.get(self, "times")


@pulumi.output_type
class EscalationPolicyRuleRoundRobin(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 rotation: Optional['outputs.EscalationPolicyRuleRoundRobinRotation'] = None):
        pulumi.set(__self__, "enabled", enabled)
        if rotation is not None:
            pulumi.set(__self__, "rotation", rotation)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rotation(self) -> Optional['outputs.EscalationPolicyRuleRoundRobinRotation']:
        return pulumi.get(self, "rotation")


@pulumi.output_type
class EscalationPolicyRuleRoundRobinRotation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delayMinutes":
            suggest = "delay_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EscalationPolicyRuleRoundRobinRotation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EscalationPolicyRuleRoundRobinRotation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EscalationPolicyRuleRoundRobinRotation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delay_minutes: Optional[int] = None,
                 enabled: Optional[bool] = None):
        if delay_minutes is not None:
            pulumi.set(__self__, "delay_minutes", delay_minutes)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> Optional[int]:
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class EscalationPolicyRuleTarget(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: EscalationPolicy id.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        EscalationPolicy id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class RoutingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isBasic":
            suggest = "is_basic"
        elif key == "routeToId":
            suggest = "route_to_id"
        elif key == "routeToType":
            suggest = "route_to_type"
        elif key == "basicExpressions":
            suggest = "basic_expressions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoutingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoutingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoutingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_basic: bool,
                 route_to_id: str,
                 route_to_type: str,
                 basic_expressions: Optional[Sequence['outputs.RoutingRulesRuleBasicExpression']] = None,
                 expression: Optional[str] = None):
        """
        :param bool is_basic: is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        :param str route_to_id: The id of the entity (user, escalation policy, squad) for which we are routing this incident.
        :param str route_to_type: Type of the entity for which we are routing this incident - User, Escalation Policy or Squad
        :param Sequence['RoutingRulesRuleBasicExpressionArgs'] basic_expressions: The basic expression which needs to be evaluated to be true for this rule to apply.
        :param str expression: The expression which needs to be evaluated to be true for this rule to apply.
        """
        pulumi.set(__self__, "is_basic", is_basic)
        pulumi.set(__self__, "route_to_id", route_to_id)
        pulumi.set(__self__, "route_to_type", route_to_type)
        if basic_expressions is not None:
            pulumi.set(__self__, "basic_expressions", basic_expressions)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="isBasic")
    def is_basic(self) -> bool:
        """
        is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        """
        return pulumi.get(self, "is_basic")

    @property
    @pulumi.getter(name="routeToId")
    def route_to_id(self) -> str:
        """
        The id of the entity (user, escalation policy, squad) for which we are routing this incident.
        """
        return pulumi.get(self, "route_to_id")

    @property
    @pulumi.getter(name="routeToType")
    def route_to_type(self) -> str:
        """
        Type of the entity for which we are routing this incident - User, Escalation Policy or Squad
        """
        return pulumi.get(self, "route_to_type")

    @property
    @pulumi.getter(name="basicExpressions")
    def basic_expressions(self) -> Optional[Sequence['outputs.RoutingRulesRuleBasicExpression']]:
        """
        The basic expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "basic_expressions")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        The expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class RoutingRulesRuleBasicExpression(dict):
    def __init__(__self__, *,
                 lhs: str,
                 rhs: str):
        pulumi.set(__self__, "lhs", lhs)
        pulumi.set(__self__, "rhs", rhs)

    @property
    @pulumi.getter
    def lhs(self) -> str:
        return pulumi.get(self, "lhs")

    @property
    @pulumi.getter
    def rhs(self) -> str:
        return pulumi.get(self, "rhs")


@pulumi.output_type
class RunbookEntityOwner(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: Runbook owner id.
        :param str type: Runbook owner type. (user or squad or team)
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Runbook owner id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Runbook owner type. (user or squad or team)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RunbookStep(dict):
    def __init__(__self__, *,
                 content: str):
        pulumi.set(__self__, "content", content)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")


@pulumi.output_type
class SLOEntityOwner(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: SLO owner id.
        :param str type: SLO owner type (user, team, squad).
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        SLO owner id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        SLO owner type (user, team, squad).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SLONotify(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceId":
            suggest = "service_id"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "squadIds":
            suggest = "squad_ids"
        elif key == "userIds":
            suggest = "user_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SLONotify. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SLONotify.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SLONotify.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[int] = None,
                 service_id: Optional[str] = None,
                 slo_id: Optional[int] = None,
                 squad_ids: Optional[Sequence[str]] = None,
                 user_ids: Optional[Sequence[str]] = None):
        """
        :param int id: The ID of the notification rule
        :param str service_id: The ID of the service in which the user want to create an incident
        :param int slo_id: The ID of the SLO.
        :param Sequence[str] squad_ids: List of Squad ID's who should be alerted via email.
        :param Sequence[str] user_ids: List of user ID's who should be alerted via email.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if service_id is not None:
            pulumi.set(__self__, "service_id", service_id)
        if slo_id is not None:
            pulumi.set(__self__, "slo_id", slo_id)
        if squad_ids is not None:
            pulumi.set(__self__, "squad_ids", squad_ids)
        if user_ids is not None:
            pulumi.set(__self__, "user_ids", user_ids)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        The ID of the notification rule
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> Optional[str]:
        """
        The ID of the service in which the user want to create an incident
        """
        return pulumi.get(self, "service_id")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> Optional[int]:
        """
        The ID of the SLO.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="squadIds")
    def squad_ids(self) -> Optional[Sequence[str]]:
        """
        List of Squad ID's who should be alerted via email.
        """
        return pulumi.get(self, "squad_ids")

    @property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[Sequence[str]]:
        """
        List of user ID's who should be alerted via email.
        """
        return pulumi.get(self, "user_ids")


@pulumi.output_type
class SLORule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isChecked":
            suggest = "is_checked"
        elif key == "sloId":
            suggest = "slo_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SLORule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SLORule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SLORule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 id: Optional[int] = None,
                 is_checked: Optional[bool] = None,
                 slo_id: Optional[int] = None,
                 threshold: Optional[int] = None):
        """
        :param str name: The name of monitoring check."Supported values are "breached*error*budget", "unhealthy*slo","increased*false*positives", "remaining*error_budget"
        :param int id: The ID of the monitoring rule
        :param bool is_checked: Is checked?
        :param int slo_id: The ID of the SLO
        :param int threshold: Threshold for the monitoring checkOnly supported for rules name "increased*false*positives" and "remaining*error*budget"
        """
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if is_checked is not None:
            pulumi.set(__self__, "is_checked", is_checked)
        if slo_id is not None:
            pulumi.set(__self__, "slo_id", slo_id)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of monitoring check."Supported values are "breached*error*budget", "unhealthy*slo","increased*false*positives", "remaining*error_budget"
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        The ID of the monitoring rule
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isChecked")
    def is_checked(self) -> Optional[bool]:
        """
        Is checked?
        """
        return pulumi.get(self, "is_checked")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> Optional[int]:
        """
        The ID of the SLO
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[int]:
        """
        Threshold for the monitoring checkOnly supported for rules name "increased*false*positives" and "remaining*error*budget"
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class ScheduleRotationV2ParticipantGroup(dict):
    def __init__(__self__, *,
                 participants: Optional[Sequence['outputs.ScheduleRotationV2ParticipantGroupParticipant']] = None):
        """
        :param Sequence['ScheduleRotationV2ParticipantGroupParticipantArgs'] participants: Group participants.
        """
        if participants is not None:
            pulumi.set(__self__, "participants", participants)

    @property
    @pulumi.getter
    def participants(self) -> Optional[Sequence['outputs.ScheduleRotationV2ParticipantGroupParticipant']]:
        """
        Group participants.
        """
        return pulumi.get(self, "participants")


@pulumi.output_type
class ScheduleRotationV2ParticipantGroupParticipant(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: Rotation id.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Rotation id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class ScheduleRotationV2ShiftTimeslot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startHour":
            suggest = "start_hour"
        elif key == "startMinute":
            suggest = "start_minute"
        elif key == "dayOfWeek":
            suggest = "day_of_week"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleRotationV2ShiftTimeslot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleRotationV2ShiftTimeslot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleRotationV2ShiftTimeslot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: int,
                 start_hour: int,
                 start_minute: int,
                 day_of_week: Optional[str] = None):
        """
        :param int duration: Defines the duration of each shift. (in minutes)
        :param int start_hour: Defines the start hour of the each shift in the schedule timezone.
        :param int start_minute: Defines the start minute of the each shift in the schedule timezone.
        :param str day_of_week: Defines the day of the week for the shift. If not specified, the timeslot is active on all days of the week.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_hour", start_hour)
        pulumi.set(__self__, "start_minute", start_minute)
        if day_of_week is not None:
            pulumi.set(__self__, "day_of_week", day_of_week)

    @property
    @pulumi.getter
    def duration(self) -> int:
        """
        Defines the duration of each shift. (in minutes)
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startHour")
    def start_hour(self) -> int:
        """
        Defines the start hour of the each shift in the schedule timezone.
        """
        return pulumi.get(self, "start_hour")

    @property
    @pulumi.getter(name="startMinute")
    def start_minute(self) -> int:
        """
        Defines the start minute of the each shift in the schedule timezone.
        """
        return pulumi.get(self, "start_minute")

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> Optional[str]:
        """
        Defines the day of the week for the shift. If not specified, the timeslot is active on all days of the week.
        """
        return pulumi.get(self, "day_of_week")


@pulumi.output_type
class ScheduleV2EntityOwner(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: Schedule owner id.
        :param str type: Schedule owner type (user, team, squad).
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Schedule owner id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Schedule owner type (user, team, squad).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ScheduleV2Tag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 color: Optional[str] = None):
        """
        :param str key: Schedule tag key.
        :param str value: Schedule tag value.
        :param str color: Schedule tag color.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if color is not None:
            pulumi.set(__self__, "color", color)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Schedule tag key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Schedule tag value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        Schedule tag color.
        """
        return pulumi.get(self, "color")


@pulumi.output_type
class SebformInputField(dict):
    def __init__(__self__, *,
                 label: Optional[str] = None,
                 options: Optional[Sequence[str]] = None):
        """
        :param str label: Input field Label.
        :param Sequence[str] options: Input field options.
        """
        if label is not None:
            pulumi.set(__self__, "label", label)
        if options is not None:
            pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        Input field Label.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def options(self) -> Optional[Sequence[str]]:
        """
        Input field options.
        """
        return pulumi.get(self, "options")


@pulumi.output_type
class SebformOwner(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str,
                 name: Optional[str] = None):
        """
        :param str id: Form owner id.
        :param str type: Form owner type (user, team, squad).
        :param str name: Form owner name.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Form owner id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Form owner type (user, team, squad).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Form owner name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SebformService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceId":
            suggest = "service_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SebformService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SebformService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SebformService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_id: str,
                 alias: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str service_id: Service ID.
        :param str alias: Service alias.
        :param str name: Service name.
        """
        pulumi.set(__self__, "service_id", service_id)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> str:
        """
        Service ID.
        """
        return pulumi.get(self, "service_id")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        Service alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SebformSeverity(dict):
    def __init__(__self__, *,
                 type: str,
                 description: Optional[str] = None):
        """
        :param str type: Severity type.
        :param str description: Severity description.
        """
        pulumi.set(__self__, "type", type)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Severity type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Severity description.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class ServiceMaintainer(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: The id of the maintainer.
        :param str type: The type of the maintainer. (user, team or squad)
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the maintainer.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the maintainer. (user, team or squad)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceMaintenanceWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"
        elif key == "repeatFrequency":
            suggest = "repeat_frequency"
        elif key == "repeatTill":
            suggest = "repeat_till"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceMaintenanceWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceMaintenanceWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceMaintenanceWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: str,
                 till: str,
                 repeat_frequency: Optional[str] = None,
                 repeat_till: Optional[str] = None):
        """
        :param str from_: Starting Time
        :param str till: End Time.
        :param str repeat_frequency: repeat frequency. ('day', 'week', '2 weeks', '3 weeks', 'month')
        :param str repeat_till: Till when you want to repeat this Maintenance mode
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "till", till)
        if repeat_frequency is not None:
            pulumi.set(__self__, "repeat_frequency", repeat_frequency)
        if repeat_till is not None:
            pulumi.set(__self__, "repeat_till", repeat_till)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> str:
        """
        Starting Time
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def till(self) -> str:
        """
        End Time.
        """
        return pulumi.get(self, "till")

    @property
    @pulumi.getter(name="repeatFrequency")
    def repeat_frequency(self) -> Optional[str]:
        """
        repeat frequency. ('day', 'week', '2 weeks', '3 weeks', 'month')
        """
        return pulumi.get(self, "repeat_frequency")

    @property
    @pulumi.getter(name="repeatTill")
    def repeat_till(self) -> Optional[str]:
        """
        Till when you want to repeat this Maintenance mode
        """
        return pulumi.get(self, "repeat_till")


@pulumi.output_type
class ServiceTag(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: key
        :param str value: value
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        key
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        value
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SuppressionRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isBasic":
            suggest = "is_basic"
        elif key == "basicExpressions":
            suggest = "basic_expressions"
        elif key == "isTimebased":
            suggest = "is_timebased"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SuppressionRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SuppressionRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SuppressionRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_basic: bool,
                 basic_expressions: Optional[Sequence['outputs.SuppressionRulesRuleBasicExpression']] = None,
                 description: Optional[str] = None,
                 expression: Optional[str] = None,
                 is_timebased: Optional[bool] = None,
                 timeslots: Optional[Sequence['outputs.SuppressionRulesRuleTimeslot']] = None):
        """
        :param bool is_basic: is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        :param Sequence['SuppressionRulesRuleBasicExpressionArgs'] basic_expressions: The basic expression which needs to be evaluated to be true for this rule to apply.
        :param str description: description.
        :param str expression: The expression which needs to be evaluated to be true for this rule to apply.
        :param bool is_timebased: is_timebased will be true when users use the time based suppression rule
        :param Sequence['SuppressionRulesRuleTimeslotArgs'] timeslots: The timeslots for which this rule should be applied.
        """
        pulumi.set(__self__, "is_basic", is_basic)
        if basic_expressions is not None:
            pulumi.set(__self__, "basic_expressions", basic_expressions)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if is_timebased is not None:
            pulumi.set(__self__, "is_timebased", is_timebased)
        if timeslots is not None:
            pulumi.set(__self__, "timeslots", timeslots)

    @property
    @pulumi.getter(name="isBasic")
    def is_basic(self) -> bool:
        """
        is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        """
        return pulumi.get(self, "is_basic")

    @property
    @pulumi.getter(name="basicExpressions")
    def basic_expressions(self) -> Optional[Sequence['outputs.SuppressionRulesRuleBasicExpression']]:
        """
        The basic expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "basic_expressions")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        The expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="isTimebased")
    def is_timebased(self) -> Optional[bool]:
        """
        is_timebased will be true when users use the time based suppression rule
        """
        return pulumi.get(self, "is_timebased")

    @property
    @pulumi.getter
    def timeslots(self) -> Optional[Sequence['outputs.SuppressionRulesRuleTimeslot']]:
        """
        The timeslots for which this rule should be applied.
        """
        return pulumi.get(self, "timeslots")


@pulumi.output_type
class SuppressionRulesRuleBasicExpression(dict):
    def __init__(__self__, *,
                 lhs: str,
                 op: str,
                 rhs: str):
        pulumi.set(__self__, "lhs", lhs)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "rhs", rhs)

    @property
    @pulumi.getter
    def lhs(self) -> str:
        return pulumi.get(self, "lhs")

    @property
    @pulumi.getter
    def op(self) -> str:
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def rhs(self) -> str:
        return pulumi.get(self, "rhs")


@pulumi.output_type
class SuppressionRulesRuleTimeslot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "endsOn":
            suggest = "ends_on"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"
        elif key == "endsNever":
            suggest = "ends_never"
        elif key == "isAllday":
            suggest = "is_allday"
        elif key == "isCustom":
            suggest = "is_custom"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SuppressionRulesRuleTimeslot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SuppressionRulesRuleTimeslot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SuppressionRulesRuleTimeslot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: str,
                 ends_on: str,
                 repetition: str,
                 start_time: str,
                 time_zone: str,
                 customs: Optional[Sequence['outputs.SuppressionRulesRuleTimeslotCustom']] = None,
                 ends_never: Optional[bool] = None,
                 is_allday: Optional[bool] = None,
                 is_custom: Optional[bool] = None):
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "ends_on", ends_on)
        pulumi.set(__self__, "repetition", repetition)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)
        if customs is not None:
            pulumi.set(__self__, "customs", customs)
        if ends_never is not None:
            pulumi.set(__self__, "ends_never", ends_never)
        if is_allday is not None:
            pulumi.set(__self__, "is_allday", is_allday)
        if is_custom is not None:
            pulumi.set(__self__, "is_custom", is_custom)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="endsOn")
    def ends_on(self) -> str:
        return pulumi.get(self, "ends_on")

    @property
    @pulumi.getter
    def repetition(self) -> str:
        return pulumi.get(self, "repetition")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter
    def customs(self) -> Optional[Sequence['outputs.SuppressionRulesRuleTimeslotCustom']]:
        return pulumi.get(self, "customs")

    @property
    @pulumi.getter(name="endsNever")
    def ends_never(self) -> Optional[bool]:
        return pulumi.get(self, "ends_never")

    @property
    @pulumi.getter(name="isAllday")
    def is_allday(self) -> Optional[bool]:
        return pulumi.get(self, "is_allday")

    @property
    @pulumi.getter(name="isCustom")
    def is_custom(self) -> Optional[bool]:
        return pulumi.get(self, "is_custom")


@pulumi.output_type
class SuppressionRulesRuleTimeslotCustom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repeatsCount":
            suggest = "repeats_count"
        elif key == "repeatsOnMonth":
            suggest = "repeats_on_month"
        elif key == "repeatsOnWeekdays":
            suggest = "repeats_on_weekdays"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SuppressionRulesRuleTimeslotCustom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SuppressionRulesRuleTimeslotCustom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SuppressionRulesRuleTimeslotCustom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repeats: str,
                 repeats_count: Optional[int] = None,
                 repeats_on_month: Optional[str] = None,
                 repeats_on_weekdays: Optional[Sequence[int]] = None):
        pulumi.set(__self__, "repeats", repeats)
        if repeats_count is not None:
            pulumi.set(__self__, "repeats_count", repeats_count)
        if repeats_on_month is not None:
            pulumi.set(__self__, "repeats_on_month", repeats_on_month)
        if repeats_on_weekdays is not None:
            pulumi.set(__self__, "repeats_on_weekdays", repeats_on_weekdays)

    @property
    @pulumi.getter
    def repeats(self) -> str:
        return pulumi.get(self, "repeats")

    @property
    @pulumi.getter(name="repeatsCount")
    def repeats_count(self) -> Optional[int]:
        return pulumi.get(self, "repeats_count")

    @property
    @pulumi.getter(name="repeatsOnMonth")
    def repeats_on_month(self) -> Optional[str]:
        return pulumi.get(self, "repeats_on_month")

    @property
    @pulumi.getter(name="repeatsOnWeekdays")
    def repeats_on_weekdays(self) -> Optional[Sequence[int]]:
        return pulumi.get(self, "repeats_on_weekdays")


@pulumi.output_type
class TaggingRulesRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isBasic":
            suggest = "is_basic"
        elif key == "basicExpressions":
            suggest = "basic_expressions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TaggingRulesRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TaggingRulesRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TaggingRulesRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_basic: bool,
                 basic_expressions: Optional[Sequence['outputs.TaggingRulesRuleBasicExpression']] = None,
                 expression: Optional[str] = None,
                 tags: Optional[Sequence['outputs.TaggingRulesRuleTag']] = None):
        """
        :param bool is_basic: is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        :param Sequence['TaggingRulesRuleBasicExpressionArgs'] basic_expressions: The basic expression which needs to be evaluated to be true for this rule to apply.
        :param str expression: The expression which needs to be evaluated to be true for this rule to apply.
        :param Sequence['TaggingRulesRuleTagArgs'] tags: The tags supposed to be set for a given payload(incident), Expression must be set when tags are empty and must contain addTags parameters.
        """
        pulumi.set(__self__, "is_basic", is_basic)
        if basic_expressions is not None:
            pulumi.set(__self__, "basic_expressions", basic_expressions)
        if expression is not None:
            pulumi.set(__self__, "expression", expression)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="isBasic")
    def is_basic(self) -> bool:
        """
        is_basic will be true when users use the drop down selectors which will have lhs, op & rhs value, whereas it will be false when they use the advanced mode and it would have the expression for it's value
        """
        return pulumi.get(self, "is_basic")

    @property
    @pulumi.getter(name="basicExpressions")
    def basic_expressions(self) -> Optional[Sequence['outputs.TaggingRulesRuleBasicExpression']]:
        """
        The basic expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "basic_expressions")

    @property
    @pulumi.getter
    def expression(self) -> Optional[str]:
        """
        The expression which needs to be evaluated to be true for this rule to apply.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.TaggingRulesRuleTag']]:
        """
        The tags supposed to be set for a given payload(incident), Expression must be set when tags are empty and must contain addTags parameters.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class TaggingRulesRuleBasicExpression(dict):
    def __init__(__self__, *,
                 lhs: str,
                 op: str,
                 rhs: str):
        pulumi.set(__self__, "lhs", lhs)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "rhs", rhs)

    @property
    @pulumi.getter
    def lhs(self) -> str:
        return pulumi.get(self, "lhs")

    @property
    @pulumi.getter
    def op(self) -> str:
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def rhs(self) -> str:
        return pulumi.get(self, "rhs")


@pulumi.output_type
class TaggingRulesRuleTag(dict):
    def __init__(__self__, *,
                 color: str,
                 key: str,
                 value: str):
        pulumi.set(__self__, "color", color)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetEscalationPolicyEntityOwnerResult(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: Escalation policy owner id.
        :param str type: Escalation policy owner type. (user or squad or team)
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Escalation policy owner id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Escalation policy owner type. (user or squad or team)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEscalationPolicyRepeatResult(dict):
    def __init__(__self__, *,
                 delay_minutes: int,
                 times: int):
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "times", times)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> int:
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter
    def times(self) -> int:
        return pulumi.get(self, "times")


@pulumi.output_type
class GetEscalationPolicyRuleResult(dict):
    def __init__(__self__, *,
                 delay_minutes: int,
                 notification_channels: Sequence[str],
                 repeats: Sequence['outputs.GetEscalationPolicyRuleRepeatResult'],
                 round_robins: Sequence['outputs.GetEscalationPolicyRuleRoundRobinResult'],
                 targets: Sequence['outputs.GetEscalationPolicyRuleTargetResult']):
        """
        :param Sequence['GetEscalationPolicyRuleRepeatArgs'] repeats: You can choose to repeate the entire policy, if no one acknowledges the incident even after the Escalation Policy has been executed fully once
        """
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "notification_channels", notification_channels)
        pulumi.set(__self__, "repeats", repeats)
        pulumi.set(__self__, "round_robins", round_robins)
        pulumi.set(__self__, "targets", targets)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> int:
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter(name="notificationChannels")
    def notification_channels(self) -> Sequence[str]:
        return pulumi.get(self, "notification_channels")

    @property
    @pulumi.getter
    def repeats(self) -> Sequence['outputs.GetEscalationPolicyRuleRepeatResult']:
        """
        You can choose to repeate the entire policy, if no one acknowledges the incident even after the Escalation Policy has been executed fully once
        """
        return pulumi.get(self, "repeats")

    @property
    @pulumi.getter(name="roundRobins")
    def round_robins(self) -> Sequence['outputs.GetEscalationPolicyRuleRoundRobinResult']:
        return pulumi.get(self, "round_robins")

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.GetEscalationPolicyRuleTargetResult']:
        return pulumi.get(self, "targets")


@pulumi.output_type
class GetEscalationPolicyRuleRepeatResult(dict):
    def __init__(__self__, *,
                 delay_minutes: int,
                 times: int):
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "times", times)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> int:
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter
    def times(self) -> int:
        return pulumi.get(self, "times")


@pulumi.output_type
class GetEscalationPolicyRuleRoundRobinResult(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 rotations: Sequence['outputs.GetEscalationPolicyRuleRoundRobinRotationResult']):
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "rotations", rotations)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def rotations(self) -> Sequence['outputs.GetEscalationPolicyRuleRoundRobinRotationResult']:
        return pulumi.get(self, "rotations")


@pulumi.output_type
class GetEscalationPolicyRuleRoundRobinRotationResult(dict):
    def __init__(__self__, *,
                 delay_minutes: int,
                 enabled: bool):
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> int:
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetEscalationPolicyRuleTargetResult(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: EscalationPolicy id.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        EscalationPolicy id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRunbookEntityOwnerResult(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: Runbook owner id.
        :param str type: Runbook owner type. (user or squad or team)
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Runbook owner id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Runbook owner type. (user or squad or team)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRunbookStepResult(dict):
    def __init__(__self__, *,
                 content: str):
        pulumi.set(__self__, "content", content)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")


@pulumi.output_type
class GetScheduleV2EntityOwnerResult(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: Schedule id.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Schedule id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetScheduleV2TagResult(dict):
    def __init__(__self__, *,
                 color: str,
                 key: str,
                 value: str):
        pulumi.set(__self__, "color", color)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetServiceMaintainerResult(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: The id of the maintainer.
        :param str type: The type of the maintainer. (user, team or squad)
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the maintainer.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the maintainer. (user, team or squad)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetServiceTagResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetTeamMemberResult(dict):
    def __init__(__self__, *,
                 role_ids: Sequence[str],
                 user_id: str):
        pulumi.set(__self__, "role_ids", role_ids)
        pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="roleIds")
    def role_ids(self) -> Sequence[str]:
        return pulumi.get(self, "role_ids")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetTeamRoleResult(dict):
    def __init__(__self__, *,
                 abilities: Sequence[str],
                 default: bool,
                 id: str,
                 name: str):
        """
        :param bool default: Squadcast has one default team and this field let's us know if this is the default team.
        :param str id: Team id.
        :param str name: Name of the Team.
        """
        pulumi.set(__self__, "abilities", abilities)
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def abilities(self) -> Sequence[str]:
        return pulumi.get(self, "abilities")

    @property
    @pulumi.getter
    def default(self) -> bool:
        """
        Squadcast has one default team and this field let's us know if this is the default team.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Team id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Team.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetUserNotificationRuleResult(dict):
    def __init__(__self__, *,
                 delay_minutes: int,
                 type: str):
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> int:
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetUserOncallReminderRuleResult(dict):
    def __init__(__self__, *,
                 delay_minutes: int,
                 type: str):
        pulumi.set(__self__, "delay_minutes", delay_minutes)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="delayMinutes")
    def delay_minutes(self) -> int:
        return pulumi.get(self, "delay_minutes")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetWebformInputFieldResult(dict):
    def __init__(__self__, *,
                 label: str,
                 options: Sequence[str]):
        """
        :param str label: Input field Label.
        :param Sequence[str] options: Input field options.
        """
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "options", options)

    @property
    @pulumi.getter
    def label(self) -> str:
        """
        Input field Label.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def options(self) -> Sequence[str]:
        """
        Input field options.
        """
        return pulumi.get(self, "options")


@pulumi.output_type
class GetWebformOwnerResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 type: str):
        """
        :param str id: Form owner id.
        :param str name: Form owner name.
        :param str type: Form owner type (user, team, squad).
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Form owner id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Form owner name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Form owner type (user, team, squad).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetWebformServiceResult(dict):
    def __init__(__self__, *,
                 alias: str,
                 name: str,
                 service_id: str):
        """
        :param str alias: Service alias.
        :param str name: Service name.
        :param str service_id: Service id.
        """
        pulumi.set(__self__, "alias", alias)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_id", service_id)

    @property
    @pulumi.getter
    def alias(self) -> str:
        """
        Service alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Service name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> str:
        """
        Service id.
        """
        return pulumi.get(self, "service_id")


@pulumi.output_type
class GetWebformSeverityResult(dict):
    def __init__(__self__, *,
                 description: str,
                 type: str):
        """
        :param str description: Severity description.
        :param str type: Severity type.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Severity description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Severity type.
        """
        return pulumi.get(self, "type")


